# Today I Learned 220927

## 클래스

### OOP
-객체 기반으로 코드를 구현하는 것을 말함

### 객체지향 특징

#### 캡슐화(encapusluation)/정보은닉
- 외부에서 객체의 데이터 일부를 접근하지 못하게 함
- 접근제어자/setter&getter를 통해

#### 상속
- 자식 클래스 extends 부모 클래스
- 부모 클래스에 있는 필드와 메서드를 자식이 물려받음
- 자바에서 클래스의 다중 상속 불가
- 코드의 중복을 줄이기 위함

#### 다형성
- 객체의 데이터 타입(형)이 다양하게 올 수 있는 성질
- 자식 객체는 부모 객체 변수에 살 수 있음
> 부모 클래스 = new 자식 클래스(); O

- 부모 객체는 자식 객체 변수에 살 수 없음
> 자식 클래스 = new 부모 클래스(); X

- object.method(parameter)
> object is methoded with parameter
> 보통 인자를 통해 객체가 설정되거나 수정

- 객체지향프로그래밍 개발 예시
> 쇼핑몰 고객들의 총 결제금액과 이용시간에 따라 사람들을 NORMAL, VIP, VVIP 고객으로 분류하였다
> 고객을 분류하는 함수 classify 구현한다고 가정



### 객체

#### 객체 정의
- object
- 불 수 있고 만질 수 있는 사물
- 추상적으로 생각할 수 있는 것
- 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것
- 객체 모델링
> 현실 세계의 객체를 소프트웨어 객체로 설계하는 것
> 현실 세계의 객체 속성과 동작 > 소프트웨어 객체 필드와 메서드 정의

- 소프트웨어 세계에 구현할 대상
> 프로그램 요구조건에 따라 어떤 데이터를 객체화할 것인지는 달라짐
> 보통 소프트웨어 기획단계에서 결정

- 객체들은 모두 클래스를 통해 생성할 수 있음
- 객체는 필드(데이터)와 데이터를 기능하게 하는 메서드(함수)를 가짐


#### 객체 관계
- is-a
> 상속, inheritance
> SportCar is a Car

- has-a
> 연관, association
> Circle has a point
> Circle 객체를 만들기 위해서는 point 필요

- use-a
> 의존, dependency
> Person uses a Car
> Person 객체의 특정 기능을 구현하기 위해 짧은 시간 car객체 사용


### 클래스
- 객체를 생성하기 위한 설계도
- 선언법
> 하나 이상 문자로 이루어져야 함
> 첫번째 글자는 숫자가 올 수 없음
> '$', '_'외의 특수문자 사용불가
> 키워드 사용불가

- 하나의 클래스는 여러 개의 필드와 메소드가 있을 수 있음



### 인스턴스(instance)
- 클래스를 바탕으로 실제 메모리에 할당되어 사용되는 실체
- 객체를 소프트웨어 실체화하면 인스턴스라고 부름
- instance는 object에 포함
- 일반적인 뜻
> 추상적인 개념과 구체적인 객체 사이의 관계에 초점
> 객체는 클래스의 인스턴스

- 어떤 원본(추상적인 개념)으로부터 '생성된 복제본'
> 실제 메모리를 소비하면서 행동하고 있는 실체물[][]



### 클래스 vs 객체 vs 인스턴스
- 클래스 vs 객체
> 클래스- 설계도
> 객체 - 설계도로 구현한 모든 대상

- 객체 vs 인스턴스
> 클래스 타입으로 선언되었을 때 객체라고 부름(객체변수도 가능)/Student student
> 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부름(객체가 생성되었고 사용할 수 있다는 의미로 인스턴스라고 함)/student=new Student()




## 생성자


### 정의
- new연산자를 통해 객체를 생성할 때 호출되는 메서드
- 객체 생성과 동시에 원하는 값으로 초기화할 수 있는 메서드

### 특징
- 생성자 이름은 클래스 이름과 동일
- 대부분의 클래스에서 보통 생성자는 오벌됭이 많이 되어있음
> 객체 생성을 다양하게 생성할 수 있도록 하기 위함

- 생성자 정의를 하지 않은 클래스는 자바 컴파일러가 기본 생성자 자동 생성함
- 생성자 정의를 하나라도 한 클래스는 기본 생성자가 자동생성되지 않기 때문에 기본 생성자도 정의 필요함

- 생성자 내부에서 또 다른 객체 생성은 좋은 코드가 아님
> 코드의 결합도(의존성) 낮추는 게 좋음




## 객체

### 객체 출력
- 보통 객체 출력하는 이유는 객체 내용을 보기 위해서임
- 객체 이름에는 객체 고유의 ID값이 들어있음
- 객체 내용을 출력하기 위해서는 toString() 정의


### 객체 비교

#### Object.hashcode()
- 두 객체가 다르면 객체 고유 ID값인 hashcode도 다름
- 두 객체를 비교하면 먼저 hashcode로 비교하면 빠르게 연산 가능
- hashcode가 다르면 두 객체가 같지 않음
- hashcode가 같으면 두 객체가 같거나 다를 수도 있음
> 객체 고유 ID값이 같기 때문에 두 객체가 같을 수도 있음
> 객체 고유 ID값이 같아도 내용물이 다를 수 있음
> > 보통 hashing 알고리즘이 잘못되었거나 충돌이 일어나는 경우임

- hashcode = s[0]*31^(n-1)+s[1]*31^(n-2)+...+s[n-1]으로 계산
> 31은 소수이기 때문에 hashcode가 중복될 가능성이 적음
> hash의 충돌을 최대한 막기 위한 방법


#### Object.equals()
- 두 객체가 equals()에 의해 동일하다면 두 객체의 hashcode()값도 일치해야함 
> 내용물이 다 같다는 소리는 같은 객체임을 의미

- 두 객체가 equals()에 의해 동일하지 않다면 두 객체의 hashcode() 값은 일치하지 않아도 됨
> 다른 값을 리턴하면 hash table 성능 향상

- equals() 재정의하면 hashcode()도 재정의해야함
> 같은 객체에 대해서 같은 값을 리턴하도록 구현해야 함


#### Comparable vs Comparator



### 객체 복사

#### Object.clone()
- 객체 복사는 Cloneable이라는 인터페이스의 clone 함수 재정의 가능

- static newInstance() 팩토리 메서드를 통해 생성할 수도 있음
- 객체 복사는 객체 내부의 배열이나 객체가 있는 경우에는 deep copy 수행




## 캡슐화

### 정의
- 관련이 있는 필드와 메서드를 하나로 묶고 외부에서 쉽게 접근하지 못하도록 구현하는 방법
- 객체의 필드에 직접적인 접근을 막고 외부에서 내부의 정보를 변경하지 못하도록 함 private 필드
- 객체가 제공하는 메서드를 통해서만 접근 가능 public 메서드
- 외부에서 직접 접근도 가능


### 구현 방법

#### 접근 제어자

- private : 클래스 내부 세부 구현하기 위해 사용
- default : 접근 제어 기본값
- protected
- public : private 필드와 프로그램 사이 인터페이스 역할


#### setter/getter

- 객체 접근하는데 필드는 숨기고 메서드를 통해서만 접근 가능하게 함
- 메서드 내부에서는 정보손상이나 유효하지 않은 데이터를 막는 로직을 구현할 수 있음(if나 regex를 통해)
- 메서드를 한번 거쳐서 유효한 데이터만 필드에 등록될 수 있도록 함


#### 장점
- 객체 모듈화 가능
- 코드 이식성 좋아짐

