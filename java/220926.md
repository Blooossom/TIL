# Today I Learned 220926

## 배열

### 일차원 배열

#### 변수는 한 개의 데이터만 저장할 수 있음


#### 동일한 데이터 타입을 여러 개 저장하고 싶을 경우 > 배열 사용
- 인덱스는 0부터 시작
- 배열 원소 사이에는 순서가 존재
- 하나의 배열 이름을 공유할 수 있기 때문에 나중에 for문과 같이 사용


#### 선언 방법
- 배열 선언 시 저장할 원소 개수만 알고 있는 경우
> 데이터 타입[] 배열변수 이름 = new 데이터 타입[데이터 개수];

- 배열 선언 시 원소 값을 알고 있는 경우
> 데이터 타입[] 배열변수 이름 = {..., ..., ..., ...};
> ++ int[] score3; 
> score3 = {90, 80, 77, 100};으로는 초기화 불가

> ++ 배열은 for-each 구문 사용 가능
> 인덱스가 내부에 존재하기 때문에 간단한 출력을 위해 사용
> 만약 인덱스를 사용해야하는 경우라면 다른 for문 이용해야함


#### 배열 객체가 없다면? null로 초기화 가능
- 데이터 타입[] 배열변수 이름 = null;


#### 메모리
- 원소가 원시타입인 경우
- 배열 변수에는 첫번째 원소 주소만 저장됨
- 다른 원소는 어차피 원소가 연속적으로 저장되기 때문에 주소 인덱싱을 통해 접근 가능함


### 이차원 배열
- 행과 열을 가진 테이블 형태의 데이터를 저장할 경우 이차원 배열 사용함
- 사실상 이차원 배열이라는 개념은 물리적으로 존재하지 않음 > 일차원 배열로 저장


#### 선언 방법
- 배열 선언 시 저장할 행과 열의 개수만 알고 있는 경우
> 데이터 타입[][] 배열변수 이름 = new 데이터 타입[행의 크기][열의 크기];

- 배열 선언 시 원소값을 알고 있는 경우
> 데이터 타입[][] 배열변수 이름 = {{..., ..., ...}.{..., ..., ...}};

- 배열 객체가 엇다면 null 초기화 가능함
> 데이터 타입[] 배열변수 이름 = null;


#### Row-major order vs Column-major order
- row-major order : C/C++, Pascal and Python
- column-major order : Fortran, Julia, R and Matlab
- Java는 row-major로 일차원 배열 저장(정확하게 row-major는 아님)

- int[1][1]을 가져올 때 처음부터 검색하면서 찾는 게 아님
> 1. int[1] 일차원 배열이 저장된 주소를 가져옴
> 2. int[1] 일차원 배열중 1 인덱스 원소를 가져옴
- 데이터가 순차적으로 저장하는 형태가 아니기 때문에 cache hit가 어려움


#### 메모리
- 원소가 원시타입인 경우
> int[][] nums2d = {{1,2,3},{4,5,6},{7,8,9}};
- 배열 변수에는 첫번째 원소 주소만 저장됨
- int[] nums2d에는 실제 데이터의 주소가 배열로 저장되어 있음

- 다른 원소 접근법
> 원소가 연속적으로 저장되므로 주소 인덱싱을 통해 접근 가능
> address 크기는 64비트 컴퓨터에서 8bytes

- 원소가 참조타입인 경우
- 배열 변수에는 첫번째 원소 주소만 저장됨


#### 일차원 배열 <-> 이차원 배열
- 이차원 배열은 사람에 가깝게 만들어 놓은 것이지 메모리 물리적으로는 일차원 배열로 저장
- new연산자를 통해 배열 생성하면 힙 메모리에 다음과 같이 초기화
> 1. 정수 : 0
> 2. 실수 : 0.0f/0.0
> 3. 논리 : false
> 4. 문자 : \0, \u0000
> 5. 문자열 : null


#### 배열 복사
- 배열 이름이 아닌 배열 원소를 반복하면서 복사해야함
- Shallow Copy
> 일차원 배열 복사할 경우

- Deep Copy
> 이중 구조를 가진 배열이나 객체를 복사할 경우
> 이차원 배열 복사할 경우 > 이차원 배열에는 일차원 배열을 가짐
> 객체를 복사할 경우 > 객체에는 다양한 필드나 객체를 가
짐


#### 배열 활용범위
- 배열
> 시퀀스 데이터 저장
> 벡터 연산

- 이차원 배열
> 영상 저장
> 행렬 연산

- 다양한 자료 구조
- 코테 문제




## 열거형


### 정의
- 서로 관련있는 상수끼리 열거하여 정의하는 것
- 클래스 내부에 모든 상수만 정의되어 있음
- 상수-static final
> final이라고 했으나 정확하게 말하면 상수 정의는 static final

- 특징
> 상수는 모두 대문자로 선언
> 선언된 순서에 따라 0부터 인덱스 값을 순차적으로 가짐
> 클래스처럼 사용할 수 있음
> 주로 enum으로 사용함




## 함수


### 메인함수
- 클래스 로더가 프로그램 내에 있는 클래스를 모두 로드 후
- public static void main(String[] args) 호출
> 메인함수가 static이기 때문에 동일 메모리에 있는 함수만 호출 가능
> 메인함수에서 직접 호출하는 함수들은 static으로 정의

- 정의
> 프로그램 기능/동작을 정의해놓은 공간
> 보통 협업 시 개발을 함수 단위로 나누어 개ㅏㄹ

- 목적
> 코드 재사용
> 코드 독립화(모듈화)
> 코드 가독성
> > 보통 함수는 기능을 잘 보여주기 위해 동사+목적어 형태로 작성

- 특징
> 함수의 반환값은 하나이거나 없음
> 함수의 반환값이 없을 때는 void로 지정
> 2개 이상 반환하고 싶으면 객체나 배열로 묶어야 함



### 오버로딩


#### overload(중복 정의)
- 보통 생성자를 중복정의 함
- 함수의 이름은 같으나 매개변수에 따라 다른 함수가 호출되는 성질
- 조건
> 매개변수 개수/순서/타입 중 하나가 다름
> 데이터 타입 다른 지 보는 거 아님

- 상속에서 부모의 함수를 자식이 재정의하는 오버라이딩과 비교


### 가변인자
- 인자의 개수를 알지 못할 때 가변인자로 정의 가능
- ...으로 정의
- 컴파일 시 배열로 바뀌어 연산(인자가 몇개가 들어오든 컴파일러가 코드를 해석해줌)



### 재귀함수
- 함수에서 자기 자신을 다시 호출해 작업을 수행하는 방식
- 자기자신 호출하고 원래 문제의 더 작은 하위 문제로 나누어 해결
- 보통 종료구문과 재귀구문으로 나뉨
> 종료구문 없으면 무한루프임

- 재귀함수 vs 반복문
> 재귀함수 구현은 대부분 반복문으로 바꿀 수 있음
> 반복문보다 코드의 길이가 짧음
> 재귀 호출과 함께 스택에 추가되고 호출이 완료될 때까지 값을 유지 > 많은 메모리 사용함(recursive 같은 것)



### 이슈 트래킹
- 자바에는 call by reference(참조자를 통한 호출)이 없음
- reference가 address가 아님
- 자바는 기본적으로 call by value임
- value가 일반 variable(원시타입)인 경우
- value가 참조타입인 경우가 있음
- value에 variable이 올 수도 있고, address가 올 수도 있지만, value가 address랑 같은 것은 아님
- 참조자와 참조값은 전혀 다름
