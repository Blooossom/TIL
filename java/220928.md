# Today I Learned 220928

# 정적 필드와 메서드

## 의미
- static
- 클래스에 고정된 멤버 => 클래스 멤버
- 클래스 로딩 시 같이 로딩되어 메모리 공통 영역에 존재하기 때문에 객체 생성 필요 없음
- 클래스로더가 바이트 코드로 로딩해서 메서드 메모리 영역에 적재함
- 객체마다 가지고 있어야 할 데이터면 인스턴스 필드로 선언
- 객체마다 가지고 있을 필요없는 공용 데이터라면 정적 필드로 선언
- static 안에서는 this 못 씀

## 메모리
- 공통 영역에 저장되는 것이 정적 필드임
- 메모리에 딱 한번 할당됨
- static필드를 접근하는 경우가 있으면 그 메서드도 static이어야 함

## 선언방법
- 객체들마다 새로 생성이 되는 것이 아니고,
- 클래스 하나에 하나씩 생성되는 것을 정적 필드라고함
- 클래스 필드를 Student s1을 만든다고 해서 count라는 공간이 새로 생기는 것이 아니라 Student라는 공간에 count가 있는 것

- public class 클래스 이름{
- //정적필드
- 접근제어자 static 타입필드 = 초기값;
- //정적메서드
- 접근제어자 static 반환형 메서드(매개변수, ...}{}

## 왜 메인함수는 public static void일까?
- 클래스 로더가(클래스/정적변수/정적메서드/메인함수)에 의해 읽힘
- > 함수가 스택에 쌓임
- > 클래스로 더한 값이 해제(메인함수 종료)

- 클래스로더가 static을 먼저 읽는데,
- 클래스 로더에 의해 메인함수가 먼저 메모리에 올라가야 하기 때문에
- 프로그램 종료까지 사라지지 않게 하기 위함

## 상수를 static final이라고 하는데 왜 일까?
- 굳이 새로운 공간을 생성할 필요없이 한 공용 메모리에 저장해두면 좋으니까 > 훨씬 메모리 관리하기 편함


# 정적 블록
- 이런 경우가 많지는 않음

## 목적
- 정적 필드의 복잡한 초기화를 위함

## 실행순서
- 클래스가 메모리로 로딩될 때 선언된 순서대로 실행

## 특징
- 객체가 엇이도 실행될 수 있기 때문에 this 키워드 사용 불가능


# 싱글톤 패턴

## 목적
- 전체 프로그램에서 하나의 객체만 보장해야하는 경우
- 보통 1인만 가능한 게임 설계나 데이터베이스에 접근하는 객체 설계하는 경우
> DB에 접근하는 객체는 여러 개면 안됨

- 생각보다 멀티 스레드 환경에서 고려해줘야 할 게 있는듯?


## 방법
- 생성자: private
- 정적 변수 : static uniqueInstance
- 정적 메서드 : static getInstance()//이미 생성된 객체가 있는 지 확인하고 사용

## 구현 방법
1. private 접근제어자 사용
- 이 경우 발생할 수 있는 문제는
- 멀티 스레드 환경에서 JVM은 스레드를 왔다갔다하면서
- 실행시키는데, 특정 지점에 도달한 스레드들끼리 충돌할 수 있음

2. 동기화 문제 해결
- sychronized 함수를 사용, 이 함수에 도달한 스레드의 작업이 마쳐질 때까지 다른 스레드의 진입을 막음
- 속도가 100배정도 느려진다고함

3. 처음부터 인스턴스 생성
- 인스턴스를 필요할 때 생성하지 않고 처음 클래스 로딩할 때 생성
- JVM에서 유일한 인스턴스를 생성하기 전에는 어떤 스레드도 uniqueInstance에 접근할 수 없음
- getInstance() 메서드 호출하지 않아도 인스턴스 유지하고 있음

4. DCL(Double-Checking Locking)
- 간단하게 말해서 두 번 확인하는 것
- 인스턴스가 있는지 확인하고 없으면 동기화된 블럭으로 들어감
- 블럭에 들어간 후에도 다시 한번 인스턴스가 있는지 확인하고 생성
- 2번 체크해서 double
- 인스턴스가 생기기 전 처음에만 동기화되고 그 이후로는 동기화가 발생하지 않음 > sychronized의 속도 저하 해소?



# 어노테이션

## 정의
- 메타데이터
- 애플리케이션이 처리해야 할 데이터가 아니라 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지 알려주는 정보
- @AnnotationName

## 용도
- 컴파일러에게 코드 문법 에러를 체크하도록 정보 제공용
- 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보 제공
- 실행 시 클래스의 역할/기능을 실행하도록 정보 제공
- 빌드 시 자동으로 XML 설정 파일을 생성하거나 배포를 위해 JAR 압축 파일을 생성하는데도 사용


## 적용대상

- java.lang.annotation.ElementType
- > ElementType(열거상수) : 적용대상
1. TYPE : 클래스/인터페이스/열거타입
2. ANNOTATION_TYPE : 어노테이션
3. FIELD : 필드
4. CONSTRUCTOR : 생성자
5. METHOD : 메서드
6. LOCAL_VARIABLE : 로컬 변수
7. PACKAGE : 패키지

- 어노테이션 적용 대상 지정 -@Target
- ElementType 배열로 @target 지정가능


# Algorithm

## BaekJoon
- 1546번
- 2525번
- 2884번
- 3052번
- 4344번
- 10871번
- 14645번

