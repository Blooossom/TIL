Today I Learned 220919

# Online

1. 자바 프로그래밍 시작하기

## 프로그래밍이란?
- 프로그래밍 : 컴퓨터가 일을 수행하도록 프로그래밍 언어로 명령어 집합(프로그램)을 만드는 일
- 컴파일 : 프로그래밍 언어를 컴퓨터가 실행 가능한 기계어로 만드는 일
- 컴파일러 : 기계어로 바꾸어주는 프로그램(ex:자바 컴파일러)

## 자바 프로그래밍
- 자바 프로그래밍의 특징 
> 플랫폼에 영향을 받지 않으므로 다양한 환경에서 사용 가능
> 객체지향 언어이기 때문에 유지보수가 쉽고 확장성이 좋음
> 프로그램이 안정적
> 풍부한 기능이 제공되는 오픈 소스

## 객체지향 프로그래밍이 무엇인가?
- 프로그램의 구현을 시간의 흐름 순이 아닌 객체 간의 관계와 협력을 기반으로 프로그래밍 하는 것
- Object Oriented Programming이라고 함(cf. 절차지향 프로그래밍)
- 사용하는 언어 : Java, C++, C#, Python, Javascript, Ruby등 다수

## 자바로 프로그래밍 하는 장점(OOP 장점)
- 재사용성/유지보수/코드관리/신뢰성 높음

## 자바를 활용한 프로그래밍
- 웹 서버 구현
- 안드로이드 프로그램
- 게임 프로그래밍



2. 변수

## 변수 사용
- 내용을 담을 수 있는 방을 변수로 선언하여 값을 담는 것
- 변수마다 갖는 자료형이 다를 수 있음


## 변수 선언과 사용하기 예제
- 변수 선언은 자료형과 변수명으로 선언함 
- 선언과 동시에 초기할 수 있음
- 가독성을 위해서 한번에 선언가능하지만(ex:int age, count;), 중간중간에도 선언 가능

## 변수의 이름 만들때
- 변수 이름은 영문자(대문자, 소문자)나 숫자를 사용할 수도 있고 특수문자 중에는 $와_만 사용
- 변수 이름의 시작은 숫자로 할 수 없음
- 자바에서 이미 사용하고 있는 예약어는 사용할 수 없음
- 변수 이름은 프로그램 내에서 사용되는 것으로 그 용도에 맞고 가독성이 좋게 만드는 것이 중요(길게 써도 상관없)
- 메서드 소문자로 시작해서 단어가 바뀔 때 대문자로> camel rotation



3. 자료형

## byte와 short
- byte : 1바이트 단위의 자료형 동영상, 음악파일, 실행파일의 자료를 처리할 때 사용
- short : 2바이트 단위의 자료형 C/C++ 언어와 호환 시 사용

## int
- 자바에서 사용하는 정수에 대한 기본 자료형
- 4바이트 단위의 자료형
- 프로그램에서 사용하는 숫자(리터럴)의 기본형은 int

## long
- 8바이트 자료형
- 숫자의 뒤에 알파벳 L 또는 l을 사용해 long형임을 표시
- ex) long num = 12345678900L;
- 실수타입의 기본형은 double
- float로 선언하고 싶을 때는 F또는 f를 사용

## 부동소수점 방식
- 실수는 정수보다 정밀하기 때문에 정수와는 다른 방식으로 표현해야 함
- 지수부와 가수부로 표현함
- 컴퓨터에서는 밑수를 2로 사용
- 정규화: 가수가 밑수보다 작은 한 자리 가수로 표현되는 것
- 컴퓨터에서는 밑수가 2이므로 정규화를 하게 되면 가수부분의 첫번째 자리 숫자는 항상 1임

## 부동소수점 방식의 오류
- 지수와 가수로 나타내는 부동 소수점 방식에서는 지수부가 0을 표현할 수 없기 때문에 약간의 오차가 발생할 수 있음

## 자바에서의 문자
- 문자도 정수로 표현
- 어떤 문자를 컴퓨터 내부에서 표현하기 위해 특정 정수갓을 정의
- 문자세트 : 각 문자를 얼마로 표현할 것인지 코드 값을 모아둔 것
- ex) ASKII, euc-kr, utf-8, utf-16
- 자바는 문자를 나타내기 위해 전세계 표준인 UNICODE를 사용

## 문자형 변수 선언과 사용
- 문자를 위한 데이터 타입 char ch = 'a';
- 내부적으로 숫자로 표현되므로 숫자를 넣어도 문자 출력 가능 char ch2 = 66;
- 음수는 사용 불가함

## 논리형
- true/false 두 가지만 나타냄
- 1바이트 사용
- 값이 존재하는지 배열이 비었는지 결과가 참인지 거짓인지 등을 표현

## 지역변수 자료형 없이 사용하기
- Local variable type inference
- 추론 가능한 변수에 대한 자료형을 선언하지 않음
- 하넌 선언하여 추론된 변수는 다른 타입의 값을 대입할 수 없음
- 지역변수만 사용가능(중괄호로 묶인)
- 중간에 갑자기 변경하는 것은 불가

## 상수 선언하기
- final 예약어를 사용하여 선언 > 중간에 수정 불가함
- 상수를 사용하면 변하지 않는 값을 반복하여 사용할 때 의미있는 문자로 인식하기 쉬움
- 변하더라도 선언한 부분만 변경하면 되므로 여러 부분을 수정할 필요가 없음

## 리터럴
- 프로그램에서 사용하는 숫자, 문자, 논리값을 뜻함
- 리터럴은 상수 풀에 있음
- 정수 리터럴은 int로 실수 리터럴은 double로 저장됨
- 정수의 범위가 넘어가는 경우는 L,l을 float로 사용하려는 경우는 F,f식별자

## 형 변환(type conversion)
- 서로 다른 자료형 간에 연산 등의 수행을 위해 하나의 자료형으로 통일
- 묵시적 형변환(자동형변환)과 명시적 형변환(강제형변환)이 있음
- 바이트 크기가 작거나 덜 정밀한 자료형 > 큰 자료형이거나 더 정밀한 자료형 = 자동
- 반대일 경우 강제형변환
- ++ 실수 > 정수 강제 캐스팅 필요



4. 연산자

## 대입 연산자
- = : R value를 L value에 대입

## 부호 연산자
- 단항연산자
- 변수의 부호를 유지하거나 바꿈

## 산술 연산자
- + : 두 항을 더함
- - : 앞에 있는 항에서 뒤에 있는 항을 뻄
- * : 두 항을 곱함
- / : 앞에 있는 항에서 뒤에 있는 항을 나누어 몫을 구함
- % : 앞에 있는 항에서 뒤에 있는 항을 나누어 나머지를 구함
- % 나머지 구하는 연산자, 숫자 n의 나머지 범위는 0~n-1

## 복합 대입 연산자
- 대입연산자와 다른 연산자가 함께 쓰임
- += : 두 항의 값을 더해서 왼쪽 항에 대입
- -= : 왼쪽 항에서 오른쪽 항을 빼서 그 값을 왼쪽 항에 대입
- *= : 두 항의 값을 곱해서 왼쪽 항에 대입
- /= : 왼쪽 항을 오른쪽 항으로 나누어 그 몫을 왼쪽 항에 대입
- %= : 왼쪽 항을 오른쪽 항으로 나누어 그 나머지를 왼쪽 항에 대입
- <<= : 비트를 왼쪽으로 이동하고 그 값을 왼쪽 항에 대입
- >>= : 비트를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입(왼쪽에 채워지는 비트 값은 부호 비트와 동일)
- >>>= 비트를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입(왼쪽에 채워지는 비트 값은 0)
- &= : 두 항의 &비트 연산 후 그 값을 왼쪽 항에 대입
- |= : 두 항의 | 비트 연산 후 그 값을 왼쪽 항에 대입
- ^= : 두 하의 ^비트 연산 후 그 값을 왼쪽 항에 대입

## 증가, 감소 연산자
- 단항 연산자
- 변수의 값을 1더하거나 1뺼때 사용
- 연산자가 항의 앞에 있는가 뒤에 있는가에 따라 연산 시점과 결과가 달라짐
- 문장(Statement)의 끝(;)을 기준으로 연산 시점을 생각해야함
- ++ 항의 값에 1을 더함
- -- 항의 값에서 1을 뺌

## 관계 연산자
- 이항 연산자
- 연산의 결과가 true(참) false(거짓)으로 반환됨 비교연산자라고도 함
- 조건문, 반복문의 조건식으로 많이 사용됨
- > : 왼쪽 항이 크면 참을, 아니면 거짓을 반환
- < : 왼쪽 항이 크면 참을, 아니면 거짓을 반환
- >= : 왼쪽 항이 오른쪽 항보다 크거나 같으면 참, 아니면 거짓을 반환
- <= : 왼쪽 항이 오른쪽 항보다 작거나 같으면 참, 아니면 거짓을 반환
- == : 두 개 항의 값이 같으면 참, 아니면 거짓을 반환
- != : 두 개항이 다르면 참, 아니면 거짓을 반환

## 논리 연산자
- 관계 연산자와 혼합하여 많이 사용 됨
- 연산의 결과가 true(참) false(거짓)으로 반환됨
- &&(논리곱) : 두 항이 모두 참인 경우에만 결과 값이 참 그렇지 않은 경우는 거짓
- ||(논리합) : 두 항 중 하나의 항만 참이면 결과 값은 참, 두 항이 모두 거짓이면 결과 값은 거짓
- !(부정) : 단항 연산자, 참인 경우는 거짓으로, 거짓인 경우는 참으로 변환

## 단락회로 평가
- 논리 연산에서 모든 항이 실행되지 않는 경우
- 논리 곱은 두 항의 결과가 모두 true일 때만 결과가 true
> 앞의 항의 결과가 false이면 뒤 항의 결과를 평가하지 않음
- 논리 합은 두 항의 결과가 모두 false일때만 결과가 false
> 앞의 항의 결과가 true이면 뒤 항의 결과를 평가하지 않음

## 조건 연산자
- 삼항 연산자
- 조건식의 결과가 true(참)이니 경우와 false(거짓)인 경우에 다른 결과가 수행됨
- if(조건문)을 간단히 표현할 때 사용할 수 있음

- 조건식? 결과1 : 결과2; > 조건식이 참이면 결과1 조건식이 거짓이면 결과2 가 선택

## 비트 연산자
- 대입연산자와 다른 연산자가 함께 쓰임
- 마스크 : 특정 비트를 가ㅣㄹ고 몇 개의 비트 값만 사용할 때
- ㅣ트켜기 특정 비트만을 1로 설정해서 사용하고 싶을 때
> 예)& 00001111(하위 4비트중 1인비트만 꺼내기)
- 비트끄기 : 특정비트만을 0으롤 설정해서 사용하고 싶을 때
> 예)| 11110000(하위 4비트 중0인 비트만 0으로 바꾸고 싶을때)
- 비트토글 모든 비트들을 0은 1로 1은 0으로 바꾸고 싶을 때

- ~ 비트의 반전(1의 보수)
- & 비트단위 AND
- | 비트단위 OR
- ^ 비트단위 XOR
- << 왼쪽 shift
- >>>오른쪽 shifit
- >> 오른쪽 shift

5. If문
## If문 문법
- If(조건식){수행문; //조건식이 '참'인 경우 수행문이 수행, 아니면 수행X}

# If-else문 문법
- If(조건식){수행문1;}else{수행문2;}
- 참일 경우 수행문 1이 참이 아닐 경우 수행문 2가 수행


